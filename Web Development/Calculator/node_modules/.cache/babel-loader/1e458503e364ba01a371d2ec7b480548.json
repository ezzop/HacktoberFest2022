{"ast":null,"code":"// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nvar NOT_FOUND = 'NOT_FOUND';\n\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = undefined;\n    }\n  };\n}\n\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    }); // We found a cached entry\n\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n\n      return entry.value;\n    } // No entry found in cache, return sentinel\n\n\n    return NOT_FOUND;\n  }\n\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      // TODO Is unshift slow?\n      entries.unshift({\n        key: key,\n        value: value\n      });\n\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n\n  function getEntries() {\n    return entries;\n  }\n\n  function clear() {\n    entries = [];\n  }\n\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\n\nexport var defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\nexport function createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n\n    var length = prev.length;\n\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n} // defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\n\nexport function defaultMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n      equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,\n      _providedOptions$maxS = providedOptions.maxSize,\n      maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n      resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n\n  function memoized() {\n    var value = cache.get(arguments);\n\n    if (value === NOT_FOUND) {\n      // @ts-ignore\n      value = func.apply(null, arguments);\n\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n\n        if (matchingEntry) {\n          value = matchingEntry.value;\n        }\n      }\n\n      cache.put(arguments, value);\n    }\n\n    return value;\n  }\n\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n\n  return memoized;\n}","map":{"version":3,"names":["NOT_FOUND","createSingletonCache","equals","entry","get","key","value","put","getEntries","clear","undefined","createLruCache","maxSize","entries","cacheIndex","findIndex","splice","unshift","length","pop","defaultEqualityCheck","a","b","createCacheKeyComparator","equalityCheck","areArgumentsShallowlyEqual","prev","next","i","defaultMemoize","func","equalityCheckOrOptions","providedOptions","_providedOptions$equa","_providedOptions$maxS","resultEqualityCheck","comparator","cache","memoized","arguments","apply","matchingEntry","find","clearCache"],"sources":["C:/Users/Fomonyuytar/Desktop/learning/calculator/node_modules/reselect/es/defaultMemoize.js"],"sourcesContent":["// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nvar NOT_FOUND = 'NOT_FOUND';\n\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = undefined;\n    }\n  };\n}\n\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    }); // We found a cached entry\n\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n\n      return entry.value;\n    } // No entry found in cache, return sentinel\n\n\n    return NOT_FOUND;\n  }\n\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      // TODO Is unshift slow?\n      entries.unshift({\n        key: key,\n        value: value\n      });\n\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n\n  function getEntries() {\n    return entries;\n  }\n\n  function clear() {\n    entries = [];\n  }\n\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\n\nexport var defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\nexport function createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n\n    var length = prev.length;\n\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}\n// defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\nexport function defaultMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n      equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,\n      _providedOptions$maxS = providedOptions.maxSize,\n      maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n      resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n\n  function memoized() {\n    var value = cache.get(arguments);\n\n    if (value === NOT_FOUND) {\n      // @ts-ignore\n      value = func.apply(null, arguments);\n\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n\n        if (matchingEntry) {\n          value = matchingEntry.value;\n        }\n      }\n\n      cache.put(arguments, value);\n    }\n\n    return value;\n  }\n\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n\n  return memoized;\n}"],"mappings":"AAAA;AACA;AACA,IAAIA,SAAS,GAAG,WAAhB;;AAEA,SAASC,oBAAT,CAA8BC,MAA9B,EAAsC;EACpC,IAAIC,KAAJ;EACA,OAAO;IACLC,GAAG,EAAE,SAASA,GAAT,CAAaC,GAAb,EAAkB;MACrB,IAAIF,KAAK,IAAID,MAAM,CAACC,KAAK,CAACE,GAAP,EAAYA,GAAZ,CAAnB,EAAqC;QACnC,OAAOF,KAAK,CAACG,KAAb;MACD;;MAED,OAAON,SAAP;IACD,CAPI;IAQLO,GAAG,EAAE,SAASA,GAAT,CAAaF,GAAb,EAAkBC,KAAlB,EAAyB;MAC5BH,KAAK,GAAG;QACNE,GAAG,EAAEA,GADC;QAENC,KAAK,EAAEA;MAFD,CAAR;IAID,CAbI;IAcLE,UAAU,EAAE,SAASA,UAAT,GAAsB;MAChC,OAAOL,KAAK,GAAG,CAACA,KAAD,CAAH,GAAa,EAAzB;IACD,CAhBI;IAiBLM,KAAK,EAAE,SAASA,KAAT,GAAiB;MACtBN,KAAK,GAAGO,SAAR;IACD;EAnBI,CAAP;AAqBD;;AAED,SAASC,cAAT,CAAwBC,OAAxB,EAAiCV,MAAjC,EAAyC;EACvC,IAAIW,OAAO,GAAG,EAAd;;EAEA,SAAST,GAAT,CAAaC,GAAb,EAAkB;IAChB,IAAIS,UAAU,GAAGD,OAAO,CAACE,SAAR,CAAkB,UAAUZ,KAAV,EAAiB;MAClD,OAAOD,MAAM,CAACG,GAAD,EAAMF,KAAK,CAACE,GAAZ,CAAb;IACD,CAFgB,CAAjB,CADgB,CAGZ;;IAEJ,IAAIS,UAAU,GAAG,CAAC,CAAlB,EAAqB;MACnB,IAAIX,KAAK,GAAGU,OAAO,CAACC,UAAD,CAAnB,CADmB,CACc;;MAEjC,IAAIA,UAAU,GAAG,CAAjB,EAAoB;QAClBD,OAAO,CAACG,MAAR,CAAeF,UAAf,EAA2B,CAA3B;QACAD,OAAO,CAACI,OAAR,CAAgBd,KAAhB;MACD;;MAED,OAAOA,KAAK,CAACG,KAAb;IACD,CAde,CAcd;;;IAGF,OAAON,SAAP;EACD;;EAED,SAASO,GAAT,CAAaF,GAAb,EAAkBC,KAAlB,EAAyB;IACvB,IAAIF,GAAG,CAACC,GAAD,CAAH,KAAaL,SAAjB,EAA4B;MAC1B;MACAa,OAAO,CAACI,OAAR,CAAgB;QACdZ,GAAG,EAAEA,GADS;QAEdC,KAAK,EAAEA;MAFO,CAAhB;;MAKA,IAAIO,OAAO,CAACK,MAAR,GAAiBN,OAArB,EAA8B;QAC5BC,OAAO,CAACM,GAAR;MACD;IACF;EACF;;EAED,SAASX,UAAT,GAAsB;IACpB,OAAOK,OAAP;EACD;;EAED,SAASJ,KAAT,GAAiB;IACfI,OAAO,GAAG,EAAV;EACD;;EAED,OAAO;IACLT,GAAG,EAAEA,GADA;IAELG,GAAG,EAAEA,GAFA;IAGLC,UAAU,EAAEA,UAHP;IAILC,KAAK,EAAEA;EAJF,CAAP;AAMD;;AAED,OAAO,IAAIW,oBAAoB,GAAG,SAASA,oBAAT,CAA8BC,CAA9B,EAAiCC,CAAjC,EAAoC;EACpE,OAAOD,CAAC,KAAKC,CAAb;AACD,CAFM;AAGP,OAAO,SAASC,wBAAT,CAAkCC,aAAlC,EAAiD;EACtD,OAAO,SAASC,0BAAT,CAAoCC,IAApC,EAA0CC,IAA1C,EAAgD;IACrD,IAAID,IAAI,KAAK,IAAT,IAAiBC,IAAI,KAAK,IAA1B,IAAkCD,IAAI,CAACR,MAAL,KAAgBS,IAAI,CAACT,MAA3D,EAAmE;MACjE,OAAO,KAAP;IACD,CAHoD,CAGnD;;;IAGF,IAAIA,MAAM,GAAGQ,IAAI,CAACR,MAAlB;;IAEA,KAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,MAApB,EAA4BU,CAAC,EAA7B,EAAiC;MAC/B,IAAI,CAACJ,aAAa,CAACE,IAAI,CAACE,CAAD,CAAL,EAAUD,IAAI,CAACC,CAAD,CAAd,CAAlB,EAAsC;QACpC,OAAO,KAAP;MACD;IACF;;IAED,OAAO,IAAP;EACD,CAfD;AAgBD,C,CACD;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,IAAxB,EAA8BC,sBAA9B,EAAsD;EAC3D,IAAIC,eAAe,GAAG,OAAOD,sBAAP,KAAkC,QAAlC,GAA6CA,sBAA7C,GAAsE;IAC1FP,aAAa,EAAEO;EAD2E,CAA5F;EAGA,IAAIE,qBAAqB,GAAGD,eAAe,CAACR,aAA5C;EAAA,IACIA,aAAa,GAAGS,qBAAqB,KAAK,KAAK,CAA/B,GAAmCb,oBAAnC,GAA0Da,qBAD9E;EAAA,IAEIC,qBAAqB,GAAGF,eAAe,CAACpB,OAF5C;EAAA,IAGIA,OAAO,GAAGsB,qBAAqB,KAAK,KAAK,CAA/B,GAAmC,CAAnC,GAAuCA,qBAHrD;EAAA,IAIIC,mBAAmB,GAAGH,eAAe,CAACG,mBAJ1C;EAKA,IAAIC,UAAU,GAAGb,wBAAwB,CAACC,aAAD,CAAzC;EACA,IAAIa,KAAK,GAAGzB,OAAO,KAAK,CAAZ,GAAgBX,oBAAoB,CAACmC,UAAD,CAApC,GAAmDzB,cAAc,CAACC,OAAD,EAAUwB,UAAV,CAA7E,CAV2D,CAUyC;;EAEpG,SAASE,QAAT,GAAoB;IAClB,IAAIhC,KAAK,GAAG+B,KAAK,CAACjC,GAAN,CAAUmC,SAAV,CAAZ;;IAEA,IAAIjC,KAAK,KAAKN,SAAd,EAAyB;MACvB;MACAM,KAAK,GAAGwB,IAAI,CAACU,KAAL,CAAW,IAAX,EAAiBD,SAAjB,CAAR;;MAEA,IAAIJ,mBAAJ,EAAyB;QACvB,IAAItB,OAAO,GAAGwB,KAAK,CAAC7B,UAAN,EAAd;QACA,IAAIiC,aAAa,GAAG5B,OAAO,CAAC6B,IAAR,CAAa,UAAUvC,KAAV,EAAiB;UAChD,OAAOgC,mBAAmB,CAAChC,KAAK,CAACG,KAAP,EAAcA,KAAd,CAA1B;QACD,CAFmB,CAApB;;QAIA,IAAImC,aAAJ,EAAmB;UACjBnC,KAAK,GAAGmC,aAAa,CAACnC,KAAtB;QACD;MACF;;MAED+B,KAAK,CAAC9B,GAAN,CAAUgC,SAAV,EAAqBjC,KAArB;IACD;;IAED,OAAOA,KAAP;EACD;;EAEDgC,QAAQ,CAACK,UAAT,GAAsB,YAAY;IAChC,OAAON,KAAK,CAAC5B,KAAN,EAAP;EACD,CAFD;;EAIA,OAAO6B,QAAP;AACD"},"metadata":{},"sourceType":"module"}